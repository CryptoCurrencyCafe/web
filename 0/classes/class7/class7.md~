% Class 7: Merkle Trees
% 2015-02-04

<!--
   <div class="phighlight">
   [PDF version for printing](|filename|./class7.pdf)
   </div>
-->

## Schedule 

   <div class="todo">

- If you didnâ€™t get full credit for Project 1 because of failure to post
  something interesting, you can (and should!) redeem yourself and earn
  full credit by **posting an interesting comment by Thursday**.  It can
  be on (1) Discussion questions from Project 1 (2) notes from classes,
  or (3) general forum.

- **Read:** [_Chapter 6: The Bitcoin
Network_](https://github.com/aantonop/bitcoinbook/blob/develop/ch06.asciidoc),
[_Chapter 7: The
Blockchain_](https://github.com/aantonop/bitcoinbook/blob/develop/ch07.asciidoc)
from Andreas Antonopoulos' book.  (Ideally, you should finish these
before Wednesday's class, but at the latest by Monday, 9 Feb.)
   </div>

<!--
<center> 
<iframe src="//www.slideshare.net/slideshow/embed_code/43918186" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe><br>
<div class="caption">Note: due to a bug in
slideshare's updated player, ink markings no longer appear in the
viewer.  <br>If you download the slides, they are present though.
Hopefully, the player will be fixed someday. </div>
</center>
-->

# Merkle's Puzzles

Ralph Merkle, [_Publishing a New Idea_](http://merkle.com/1974/).
Includes his [cs244 project
proposal](http://merkle.com/1974/FirstCS244projectProposal.pdf)
("Discussion: No, I am not joking.") and [ACM rejection
letter](http://merkle.com/1974/ExpertLetter.pdf) ("I am sorry to have to
inform you that the paper is not in the main stream of present
cryptography thinking and I would not recommend that it be
published...").

**Construction.**

# Merkle Trees

[https://github.com/btcsuite/btcd/blob/master/blockchain/merkle.go](https://github.com/btcsuite/btcd/blob/master/blockchain/merkle.go)
(with very slight modifications just for presentation, mostly removing
comments)

```go
// HashMerkleBranches takes two hashes, treated as the left and right tree
// nodes, and returns the hash of their concatenation. 
func HashMerkleBranches(left *btcwire.ShaHash, right *btcwire.ShaHash) *btcwire.ShaHash {
   var sha [btcwire.HashSize * 2]byte
   copy(sha[:btcwire.HashSize], left.Bytes())
   copy(sha[btcwire.HashSize:], right.Bytes())
   newSha, _ := btcwire.NewShaHash(btcwire.DoubleSha256(sha[:]))
   return newSha
}

func BuildMerkleTreeStore(transactions []*btcutil.Tx) []*btcwire.ShaHash {
    nextPoT := nextPowerOfTwo(len(transactions))
    arraySize := nextPoT*2 - 1
    merkles := make([]*btcwire.ShaHash, arraySize)

    // Create the base transaction shas and populate the array with them.
    for i, tx := range transactions {
        merkles[i] = tx.Sha()
    }

    // Start the array offset after the last transaction and adjusted to the
    // next power of two.
    offset := nextPoT
    for i := 0; i < arraySize-1; i += 2 {
        switch {
           // When there is no left child node, the parent is nil too.
           case merkles[i] == nil:
              merkles[offset] = nil

           // When there is no right child, the parent is generated by
           // hashing the concatenation of the left child with itself.
           case merkles[i+1] == nil:
              newSha := HashMerkleBranches(merkles[i], merkles[i])
              merkles[offset] = newSha
       
           // The normal case sets the parent node to the double sha256
           // of the concatentation of the left and right children.
           default:
              newSha := HashMerkleBranches(merkles[i], merkles[i+1])
              merkles[offset] = newSha
       }
       offset++
    }
    return merkles
}
```

<a href="/classes/class7/merkle.png"><img src="/classes/class7/merkle.png" width=600></a>
